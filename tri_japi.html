<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Triangula√ß√£o Serra do Japi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 300px;
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #map {
            flex: 1;
            height: 100vh;
        }
        .menu-title {
            text-align: center;
            padding: 10px;
            background-color: #34495e;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .menu-option {
            padding: 12px;
            margin-bottom: 10px;
            background-color: #34495e;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .menu-option:hover {
            background-color: #3d566e;
        }
        .menu-option i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }
        .status-bar {
            padding: 10px;
            background-color: #34495e;
            text-align: center;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background-color: #f4f4f4;
            margin: 10% auto;
            padding: 20px;
            width: 80%;
            max-width: 600px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .close-btn {
            font-size: 24px;
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .btn {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        .btn:hover {
            background-color: #2980b9;
        }
        .btn-secondary {
            background-color: #7f8c8d;
        }
        .btn-secondary:hover {
            background-color: #6c7a7d;
        }
        .data-display {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: white;
        }
        .data-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .data-item:last-child {
            border-bottom: none;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 50%;
        }
        .info-box {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            max-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="menu-title">
                <h2>üéØ SISTEMA DE TRIANGULA√á√ÉO MELHORADO</h2>
                <p>V2.0</p>
            </div>
            
            <div class="menu-option" onclick="showAddPointModal()">
                <i class="fas fa-plus"></i> Adicionar ponto com dados
            </div>
            <div class="menu-option" onclick="showViewDataModal()">
                <i class="fas fa-table"></i> Visualizar todos os dados
            </div>
            <div class="menu-option" onclick="calculateTriangulation()">
                <i class="fas fa-calculator"></i> Calcular triangula√ß√£o
            </div>
            <div class="menu-option" onclick="generateMap()">
                <i class="fas fa-map"></i> Gerar mapa interativo
            </div>
            <div class="menu-option" onclick="saveData()">
                <i class="fas fa-save"></i> Salvar dados
            </div>
            <div class="menu-option" onclick="loadData()">
                <i class="fas fa-folder-open"></i> Carregar dados
            </div>
            <div class="menu-option" onclick="clearData()">
                <i class="fas fa-trash"></i> Limpar todos os dados
            </div>
            <div class="menu-option" onclick="exitSystem()">
                <i class="fas fa-sign-out-alt"></i> Sair
            </div>
            
            <div class="status-bar" id="statusBar">
                üìä Status: 0 pontos | 0 intersec√ß√µes
            </div>
        </div>
        
        <div class="main-content">
            <div id="map"></div>
        </div>
    </div>
    
    <!-- Modal para adicionar ponto -->
    <div id="addPointModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚ûï ADICIONAR PONTO COMPLETO</h2>
                <span class="close-btn" onclick="closeModal('addPointModal')">&times;</span>
            </div>
            <div class="form-group">
                <label for="pointName">üìç Nome do ponto de observa√ß√£o:</label>
                <input type="text" id="pointName" placeholder="Ex: Ponto_Norte">
            </div>
            <div class="form-group">
                <label for="pointLat">üåê Latitude (ex: -23.5505):</label>
                <input type="number" id="pointLat" step="0.000001" placeholder="-23.5505">
            </div>
            <div class="form-group">
                <label for="pointLon">üåê Longitude (ex: -46.6333):</label>
                <input type="number" id="pointLon" step="0.000001" placeholder="-46.6333">
            </div>
            <div class="form-group">
                <label for="pointAzimuth">üß≠ Azimute em graus (0-360):</label>
                <input type="number" id="pointAzimuth" min="0" max="360" step="0.1" placeholder="45.0">
                <small id="azimuthDirection">Dire√ß√£o: -</small>
            </div>
            <div class="form-group">
                <label for="pointTarget">üéØ Nome do alvo observado (opcional):</label>
                <input type="text" id="pointTarget" placeholder="Ex: Torre_Central">
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="useDistance"> üìè Informar dist√¢ncia estimada?
                </label>
                <input type="number" id="pointDistance" step="1" placeholder="Metros" style="display: none; margin-top: 5px;">
            </div>
            <div style="text-align: right;">
                <button class="btn" onclick="addPoint()">Adicionar Ponto</button>
                <button class="btn btn-secondary" onclick="closeModal('addPointModal')">Cancelar</button>
            </div>
        </div>
    </div>
    
    <!-- Modal para visualizar dados -->
    <div id="viewDataModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìä TODOS OS DADOS INSERIDOS</h2>
                <span class="close-btn" onclick="closeModal('viewDataModal')">&times;</span>
            </div>
            <div id="pointsData" class="data-display">
                <!-- Dados ser√£o inseridos aqui via JavaScript -->
            </div>
            <div id="intersectionsData" class="data-display" style="display: none;">
                <!-- Intersec√ß√µes ser√£o inseridas aqui via JavaScript -->
            </div>
            <div style="text-align: right;">
                <button class="btn btn-secondary" onclick="closeModal('viewDataModal')">Fechar</button>
            </div>
        </div>
    </div>
    
    <!-- Modal para carregar dados -->
    <div id="loadDataModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìÇ CARREGAR DADOS</h2>
                <span class="close-btn" onclick="closeModal('loadDataModal')">&times;</span>
            </div>
            <div class="form-group">
                <label for="dataFile">Selecione um arquivo JSON:</label>
                <input type="file" id="dataFile" accept=".json">
            </div>
            <div style="text-align: right;">
                <button class="btn" onclick="loadDataFromFile()">Carregar</button>
                <button class="btn btn-secondary" onclick="closeModal('loadDataModal')">Cancelar</button>
            </div>
        </div>
    </div>
    
    <!-- Modal de confirma√ß√£o -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="confirmTitle">Confirma√ß√£o</h2>
                <span class="close-btn" onclick="closeModal('confirmModal')">&times;</span>
            </div>
            <div id="confirmMessage">
                <!-- Mensagem ser√° inserida aqui via JavaScript -->
            </div>
            <div style="text-align: right; margin-top: 20px;">
                <button class="btn" id="confirmYesBtn">Sim</button>
                <button class="btn btn-secondary" onclick="closeModal('confirmModal')">N√£o</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        // Sistema de Triangula√ß√£o Melhorado
        class SistemaTriangulacaoMelhorado {
            constructor() {
                this.pontos_dados = [];  // Unifica pontos + azimutes
                this.interseccoes = [];
                this.map = null;
                this.currentMarkers = [];
                this.currentLines = [];
                
                console.log("=".repeat(60));
                console.log("üéØ SISTEMA DE TRIANGULA√á√ÉO MELHORADO - V2.0");
                console.log("=".repeat(60));
                
                this.initMap();
                this.updateStatus();
            }
            
            initMap() {
                // Inicializa o mapa com vista para o Brasil
                this.map = L.map('map').setView([-15.788497, -47.879873], 4);
                
                // Adiciona camada base do OpenStreetMap
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(this.map);
                
                // Adiciona legenda
                this.addLegend();
            }
            
            addLegend() {
                const legend = L.control({position: 'bottomleft'});
                
                legend.onAdd = () => {
                    const div = L.DomUtil.create('div', 'info legend');
                    div.innerHTML = `
                        <h4>üìç LEGENDA</h4>
                        <p><i class="fas fa-camera" style="color:blue; margin-right:5px;"></i> Pontos de Observa√ß√£o</p>
                        <p><i class="fas fa-map-marker" style="color:red; margin-right:5px;"></i> Intersec√ß√µes</p>
                        <p><span style="color:#666;">‚îÅ ‚îÅ ‚îÅ</span> Azimutes</p>
                        <p><span style="color:#000;">¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑</span> Linhas de Triangula√ß√£o</p>
                        <hr>
                        <p style="font-size:12px;">
                        <b>AZIMUTES:</b><br>
                        0¬∞ = Norte ‚Üë<br>
                        90¬∞ = Leste ‚Üí<br>
                        180¬∞ = Sul ‚Üì<br>
                        270¬∞ = Oeste ‚Üê
                        </p>
                    `;
                    return div;
                };
                
                legend.addTo(this.map);
            }
            
            addInfoBox() {
                // Remove a info box existente
                const existingBox = document.querySelector('.info-box-container');
                if (existingBox) {
                    existingBox.remove();
                }
                
                if (this.pontos_dados.length === 0 && this.interseccoes.length === 0) {
                    return;
                }
                
                const infoBox = L.control({position: 'topright'});
                
                infoBox.onAdd = () => {
                    const div = L.DomUtil.create('div', 'info-box-container');
                    div.style.padding = '10px';
                    div.style.backgroundColor = 'white';
                    div.style.borderRadius = '5px';
                    div.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
                    div.style.maxWidth = '300px';
                    div.style.maxHeight = '80vh';
                    div.style.overflowY = 'auto';
                    
                    let html = `<h4 style="margin:0 0 10px 0; border-bottom:1px solid #ddd; padding-bottom:5px;">üìä INFORMA√á√ïES</h4>`;
                    
                    if (this.pontos_dados.length > 0) {
                        html += `<h5 style="margin:10px 0 5px 0; color:#0066cc;">üìç PONTOS (${this.pontos_dados.length})</h5>`;
                        this.pontos_dados.forEach(ponto => {
                            html += `
                                <div style="margin-bottom:8px; padding:5px; background-color:#f0f8ff; border-radius:3px;">
                                    <b>${ponto.nome}</b><br>
                                    <small>
                                    ‚Ä¢ ${ponto.lat.toFixed(6)}, ${ponto.lon.toFixed(6)}<br>
                                    ‚Ä¢ Az: ${ponto.azimute.toFixed(1)}¬∞ ‚Üí ${ponto.alvo}<br>
                                    ${ponto.distancia ? `‚Ä¢ Dist: ${ponto.distancia}m<br>` : ''}
                                    </small>
                                </div>
                            `;
                        });
                    }
                    
                    if (this.interseccoes.length > 0) {
                        html += `<h5 style="margin:15px 0 5px 0; color:#cc3300;">üéØ INTERSEC√á√ïES (${this.interseccoes.length})</h5>`;
                        this.interseccoes.forEach(inter => {
                            const bgColor = inter.tipo === 'mesmo_alvo' ? '#ffe6e6' : '#fff0e6';
                            html += `
                                <div style="margin-bottom:8px; padding:5px; background-color:${bgColor}; border-radius:3px;">
                                    <b>${inter.nome}</b><br>
                                    <small>
                                    ‚Ä¢ ${inter.lat.toFixed(6)}, ${inter.lon.toFixed(6)}<br>
                                    ‚Ä¢ Entre: ${inter.pontos_origem.join(' & ')}<br>
                                    ${inter.precisao ? `‚Ä¢ Precis√£o: ${inter.precisao.toFixed(1)}m<br>` : ''}
                                    </small>
                                </div>
                            `;
                        });
                    }
                    
                    html += `
                        <hr style="margin:10px 0 5px 0;">
                        <div style="text-align:center; font-size:11px; color:#666;">
                        <b>Sistema de Triangula√ß√£o v2.0</b><br>
                        ${new Date().toLocaleString()}
                        </div>
                    `;
                    
                    div.innerHTML = html;
                    return div;
                };
                
                infoBox.addTo(this.map);
            }
            
            adicionar_ponto_completo(nome, lat, lon, azimute, alvo, distancia) {
                try {
                    if (!nome) {
                        alert("‚ùå Nome n√£o pode estar vazio!");
                        return false;
                    }
                    
                    // Verifica se j√° existe
                    if (this.pontos_dados.some(p => p.nome === nome)) {
                        alert(`‚ö†Ô∏è Ponto '${nome}' j√° existe!`);
                        return false;
                    }
                    
                    // Valida√ß√£o de coordenadas
                    if (!(-90 <= lat && lat <= 90)) {
                        alert("‚ùå Latitude deve estar entre -90 e 90!");
                        return false;
                    }
                    if (!(-180 <= lon && lon <= 180)) {
                        alert("‚ùå Longitude deve estar entre -180 e 180!");
                        return false;
                    }
                    
                    // Valida√ß√£o de azimute
                    if (!(0 <= azimute && azimute <= 360)) {
                        alert("‚ùå Azimute deve estar entre 0 e 360!");
                        return false;
                    }
                    
                    // Se n√£o informou alvo, cria um padr√£o
                    if (!alvo) {
                        alvo = `Alvo_${this.pontos_dados.length + 1}`;
                    }
                    
                    // Cria objeto completo
                    const ponto_completo = {
                        nome: nome,
                        lat: lat,
                        lon: lon,
                        azimute: azimute,
                        alvo: alvo,
                        distancia: distancia || null,
                        timestamp: new Date().toLocaleString()
                    };
                    
                    this.pontos_dados.push(ponto_completo);
                    
                    console.log(`‚úÖ Ponto '${nome}' adicionado com sucesso!`);
                    this.updateStatus();
                    return true;
                    
                } catch (error) {
                    console.error(`‚ùå Erro ao adicionar ponto: ${error}`);
                    return false;
                }
            }
            
            validar_azimute(azimute) {
                if (azimute === 0) return "Norte ‚Üë";
                if (azimute === 90) return "Leste ‚Üí";
                if (azimute === 180) return "Sul ‚Üì";
                if (azimute === 270) return "Oeste ‚Üê";
                if (0 < azimute && azimute < 90) return "Nordeste ‚Üó";
                if (90 < azimute && azimute < 180) return "Sudeste ‚Üò";
                if (180 < azimute && azimute < 270) return "Sudoeste ‚Üô";
                if (270 < azimute && azimute < 360) return "Noroeste ‚Üñ";
                return "Dire√ß√£o inv√°lida";
            }
            
            calcular_bearing(lat1, lon1, lat2, lon2) {
                const lat1_rad = this.degToRad(lat1);
                const lat2_rad = this.degToRad(lat2);
                const dlon_rad = this.degToRad(lon2 - lon1);
                
                const y = Math.sin(dlon_rad) * Math.cos(lat2_rad);
                const x = Math.cos(lat1_rad) * Math.sin(lat2_rad) - 
                          Math.sin(lat1_rad) * Math.cos(lat2_rad) * Math.cos(dlon_rad);
                
                const bearing_rad = Math.atan2(y, x);
                let bearing_deg = this.radToDeg(bearing_rad);
                
                // Normaliza para 0-360
                return (bearing_deg + 360) % 360;
            }
            
            degToRad(deg) {
                return deg * (Math.PI / 180);
            }
            
            radToDeg(rad) {
                return rad * (180 / Math.PI);
            }
            
            calcular_ponto_por_azimute(lat_origem, lon_origem, azimute, distancia) {
                // Converte para radianos
                const lat1 = this.degToRad(lat_origem);
                const lon1 = this.degToRad(lon_origem);
                const bearing = this.degToRad(azimute);
                
                // Raio da Terra em metros
                const R = 6371000;
                
                // Dist√¢ncia angular
                const ang_dist = distancia / R;
                
                // C√°lculo do novo ponto
                const lat2 = Math.asin(Math.sin(lat1) * Math.cos(ang_dist) +
                                     Math.cos(lat1) * Math.sin(ang_dist) * Math.cos(bearing));
                
                const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(ang_dist) * Math.cos(lat1),
                                             Math.cos(ang_dist) - Math.sin(lat1) * Math.sin(lat2));
                
                return [this.radToDeg(lat2), this.radToDeg(lon2)];
            }
            
            interseccao_duas_linhas(ponto1, ponto2) {
                try {
                    // Converte coordenadas e azimutes para radianos
                    const lat1_rad = this.degToRad(ponto1.lat);
                    const lon1_rad = this.degToRad(ponto1.lon);
                    const lat2_rad = this.degToRad(ponto2.lat);
                    const lon2_rad = this.degToRad(ponto2.lon);
                    
                    const az1_rad = this.degToRad(ponto1.azimute);
                    const az2_rad = this.degToRad(ponto2.azimute);
                    
                    // Ponto de refer√™ncia (centro aproximado)
                    const lat_ref = (ponto1.lat + ponto2.lat) / 2;
                    const lon_ref = (ponto1.lon + ponto2.lon) / 2;
                    
                    // Converte para coordenadas locais (metros)
                    const geoParaLocal = (lat, lon) => {
                        const dlat = lat - lat_ref;
                        const dlon = lon - lon_ref;
                        // Fator de convers√£o aproximado
                        const lat_to_m = 111320.0;  // metros por grau de latitude
                        const lon_to_m = 111320.0 * Math.cos(this.degToRad(lat_ref));  // varia com latitude
                        
                        const x = dlon * lon_to_m;
                        const y = dlat * lat_to_m;
                        return {x, y};
                    };
                    
                    // Converte pontos para coordenadas locais
                    const p1_local = geoParaLocal(ponto1.lat, ponto1.lon);
                    const p2_local = geoParaLocal(ponto2.lat, ponto2.lon);
                    
                    // Calcula vetores direcionais das linhas
                    // Azimute 0¬∞ = Norte = vetor (0, 1)
                    // Azimute 90¬∞ = Leste = vetor (1, 0)
                    // Azimute 180¬∞ = Sul = vetor (0, -1)
                    // Azimute 270¬∞ = Oeste = vetor (-1, 0)
                    
                    // Vetor direcional do azimute 1
                    const dx1 = Math.sin(az1_rad);  // componente leste
                    const dy1 = Math.cos(az1_rad);  // componente norte
                    
                    // Vetor direcional do azimute 2
                    const dx2 = Math.sin(az2_rad);  // componente leste
                    const dy2 = Math.cos(az2_rad);  // componente norte
                    
                    // Equa√ß√£o da linha 1: (x,y) = (x1,y1) + t1*(dx1,dy1)
                    // Equa√ß√£o da linha 2: (x,y) = (x2,y2) + t2*(dx2,dy2)
                    //
                    // Intersec√ß√£o: x1 + t1*dx1 = x2 + t2*dx2
                    //             y1 + t1*dy1 = y2 + t2*dy2
                    //
                    // Sistema: t1*dx1 - t2*dx2 = x2 - x1
                    //         t1*dy1 - t2*dy2 = y2 - y1
                    
                    const det = dx1 * dy2 - dy1 * dx2;  // determinante
                    
                    if (Math.abs(det) < 1e-10) {
                        console.log("‚ö†Ô∏è Linhas paralelas no sistema local");
                        return null;
                    }
                    
                    // Resolve o sistema
                    const dx = p2_local.x - p1_local.x;
                    const dy = p2_local.y - p1_local.y;
                    
                    const t1 = (dx * dy2 - dy * dx2) / det;
                    
                    // Calcula ponto de intersec√ß√£o em coordenadas locais
                    const x_inter = p1_local.x + t1 * dx1;
                    const y_inter = p1_local.y + t1 * dy1;
                    
                    // Converte de volta para lat/lon
                    const dlat_inter = y_inter / 111320.0;
                    const dlon_inter = x_inter / (111320.0 * Math.cos(this.degToRad(lat_ref)));
                    
                    const lat_inter = lat_ref + dlat_inter;
                    const lon_inter = lon_ref + dlon_inter;
                    
                    // Valida√ß√£o: verifica se a intersec√ß√£o est√° em uma dire√ß√£o razo√°vel
                    const dist1 = this.calcular_distancia(ponto1.lat, ponto1.lon, lat_inter, lon_inter);
                    const dist2 = this.calcular_distancia(ponto2.lat, ponto2.lon, lat_inter, lon_inter);
                    
                    // Se a intersec√ß√£o est√° muito longe, pode estar na dire√ß√£o oposta
                    if (dist1 > 50000 || dist2 > 50000) {  // mais de 50km
                        console.log(`‚ö†Ô∏è Intersec√ß√£o muito distante: ${dist1}m e ${dist2}m`);
                        return null;
                    }
                    
                    return [lat_inter, lon_inter];
                    
                } catch (error) {
                    console.error(`‚ö†Ô∏è Erro no c√°lculo de intersec√ß√£o: ${error}`);
                    return null;
                }
            }
            
            calcular_distancia(lat1, lon1, lat2, lon2) {
                // F√≥rmula de Haversine para calcular dist√¢ncia entre dois pontos
                const R = 6371000; // Raio da Terra em metros
                const dLat = this.degToRad(lat2 - lat1);
                const dLon = this.degToRad(lon2 - lon1);
                
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                          Math.cos(this.degToRad(lat1)) * Math.cos(this.degToRad(lat2)) *
                          Math.sin(dLon / 2) * Math.sin(dLon / 2);
                
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }
            
            calcular_triangulacao() {
                console.log("üßÆ CALCULANDO TRIANGULA√á√ÉO");
                
                if (this.pontos_dados.length < 2) {
                    alert("‚ùå Necess√°rio pelo menos 2 pontos para triangula√ß√£o!");
                    return;
                }
                
                this.interseccoes = [];
                let interseccoes_calculadas = 0;
                
                console.log(`üìä Processando ${this.pontos_dados.length} pontos...`);
                
                // Agrupa pontos por alvo
                const alvos_grupos = {};
                for (const ponto of this.pontos_dados) {
                    const alvo = ponto.alvo;
                    if (!alvos_grupos[alvo]) {
                        alvos_grupos[alvo] = [];
                    }
                    alvos_grupos[alvo].push(ponto);
                }
                
                console.log(`üéØ Alvos encontrados: ${Object.keys(alvos_grupos)}`);
                
                // Calcula intersec√ß√µes para mesmo alvo
                for (const [alvo, pontos_alvo] of Object.entries(alvos_grupos)) {
                    if (pontos_alvo.length >= 2) {
                        console.log(`üìç Processando alvo: ${alvo}`);
                        
                        // Testa todas as combina√ß√µes de pares
                        for (let i = 0; i < pontos_alvo.length; i++) {
                            for (let j = i + 1; j < pontos_alvo.length; j++) {
                                const ponto1 = pontos_alvo[i];
                                const ponto2 = pontos_alvo[j];
                                
                                const intersecao = this.interseccao_duas_linhas(ponto1, ponto2);
                                
                                if (intersecao) {
                                    const [lat_inter, lon_inter] = intersecao;
                                    
                                    // Calcula precis√£o baseada na dist√¢ncia aos pontos
                                    const dist1 = this.calcular_distancia(ponto1.lat, ponto1.lon, lat_inter, lon_inter);
                                    const dist2 = this.calcular_distancia(ponto2.lat, ponto2.lon, lat_inter, lon_inter);
                                    const precisao = Math.abs(dist1 - dist2);
                                    
                                    const interseccao_info = {
                                        nome: `${alvo}_Inter_${interseccoes_calculadas + 1}`,
                                        lat: lat_inter,
                                        lon: lon_inter,
                                        alvos: [alvo],
                                        pontos_origem: [ponto1.nome, ponto2.nome],
                                        pontos_completos: [ponto1, ponto2],
                                        precisao: precisao,
                                        tipo: 'mesmo_alvo'
                                    };
                                    
                                    this.interseccoes.push(interseccao_info);
                                    interseccoes_calculadas++;
                                    
                                    console.log(`‚úÖ Intersec√ß√£o ${interseccoes_calculadas}:`);
                                    console.log(`   üìç ${lat_inter.toFixed(6)}, ${lon_inter.toFixed(6)}`);
                                    console.log(`   üìä Precis√£o: ${precisao.toFixed(1)}m`);
                                }
                            }
                        }
                    }
                }
                
                // Calcula intersec√ß√µes entre alvos diferentes (opcional)
                console.log("üîó Verificando intersec√ß√µes entre alvos diferentes...");
                let contador_inter_alvos = 0;
                
                for (let i = 0; i < this.pontos_dados.length; i++) {
                    for (let j = i + 1; j < this.pontos_dados.length; j++) {
                        const ponto1 = this.pontos_dados[i];
                        const ponto2 = this.pontos_dados[j];
                        
                        // S√≥ processa se forem alvos diferentes
                        if (ponto1.alvo !== ponto2.alvo) {
                            const intersecao = this.interseccao_duas_linhas(ponto1, ponto2);
                            
                            if (intersecao) {
                                const [lat_inter, lon_inter] = intersecao;
                                
                                const interseccao_info = {
                                    nome: `Inter_${ponto1.alvo}_${ponto2.alvo}`,
                                    lat: lat_inter,
                                    lon: lon_inter,
                                    alvos: [ponto1.alvo, ponto2.alvo],
                                    pontos_origem: [ponto1.nome, ponto2.nome],
                                    pontos_completos: [ponto1, ponto2],
                                    tipo: 'alvos_diferentes'
                                };
                                
                                this.interseccoes.push(interseccao_info);
                                interseccoes_calculadas++;
                                contador_inter_alvos++;
                            }
                        }
                    }
                }
                
                console.log(`‚ûï ${contador_inter_alvos} intersec√ß√µes entre alvos diferentes`);
                console.log(`‚úÖ Total de intersec√ß√µes calculadas: ${interseccoes_calculadas}`);
                
                this.updateStatus();
                return interseccoes_calculadas;
            }
            
            gerar_mapa() {
                console.log("üó∫Ô∏è GERANDO MAPA INTERATIVO MELHORADO");
                
                if (!this.pontos_dados) {
                    alert("‚ùå Nenhum ponto para plotar!");
                    return;
                }
                
                // Limpa marcadores e linhas existentes
                this.clearMap();
                
                // Calcula centro do mapa
                let todas_lats = this.pontos_dados.map(p => p.lat);
                let todas_lons = this.pontos_dados.map(p => p.lon);
                
                if (this.interseccoes.length > 0) {
                    todas_lats = todas_lats.concat(this.interseccoes.map(i => i.lat));
                    todas_lons = todas_lons.concat(this.interseccoes.map(i => i.lon));
                }
                
                const centro_lat = todas_lats.reduce((a, b) => a + b, 0) / todas_lats.length;
                const centro_lon = todas_lons.reduce((a, b) => a + b, 0) / todas_lons.length;
                
                // Ajusta a visualiza√ß√£o do mapa
                this.map.setView([centro_lat, centro_lon], 14);
                
                // Cores para azimutes
                const cores_azimute = ['red', 'green', 'purple', 'orange', 'darkblue', 'lightgreen',
                                     'darkred', 'pink', 'gray', 'black'];
                
                // Adiciona pontos de observa√ß√£o
                for (let i = 0; i < this.pontos_dados.length; i++) {
                    const ponto = this.pontos_dados[i];
                    const cor = cores_azimute[i % cores_azimute.length];
                    
                    // Popup com informa√ß√µes
                    const popup_text = `
                        <div style="width:250px">
                        <b>üìç ${ponto.nome}</b><br>
                        <b>Tipo:</b> Ponto de Observa√ß√£o<br>
                        <b>Coordenadas:</b><br>
                        ‚Ä¢ Lat: ${ponto.lat.toFixed(6)}<br>
                        ‚Ä¢ Lon: ${ponto.lon.toFixed(6)}<br>
                        <b>Azimute:</b> ${ponto.azimute.toFixed(1)}¬∞<br>
                        <b>Alvo:</b> ${ponto.alvo}<br>
                        ${ponto.distancia ? `<b>Dist√¢ncia:</b> ${ponto.distancia}m<br>` : ''}
                        <b>Criado:</b> ${ponto.timestamp}
                        </div>
                    `;
                    
                    // Cria marcador
                    const marker = L.marker([ponto.lat, ponto.lon], {
                        icon: L.divIcon({
                            html: `<i class="fas fa-camera" style="color:blue; font-size:20px;"></i>`,
                            iconSize: [20, 20],
                            className: 'custom-icon'
                        })
                    }).bindPopup(popup_text);
                    
                    marker.addTo(this.map);
                    this.currentMarkers.push(marker);
                    
                    // Calcula ponto final da linha usando dist√¢ncia fixa ou estimada
                    const distancia_linha = ponto.distancia || 10000;  // 10km padr√£o
                    const [lat_fim, lon_fim] = this.calcular_ponto_por_azimute(
                        ponto.lat, ponto.lon, ponto.azimute, distancia_linha
                    );
                    
                    // Linha de azimute VERDADEIRA
                    const line = L.polyline([[ponto.lat, ponto.lon], [lat_fim, lon_fim]], {
                        color: cor,
                        weight: 3,
                        opacity: 0.7,
                        dashArray: "5, 5",  // Linha tracejada para distinguir
                    }).bindTooltip(`üß≠ ${ponto.nome}: Azimute ${ponto.azimute.toFixed(1)}¬∞ ‚Üí ${ponto.alvo}`);
                    
                    line.addTo(this.map);
                    this.currentLines.push(line);
                }
                
                // Desenha linhas de triangula√ß√£o (at√© intersec√ß√µes)
                if (this.interseccoes.length > 0) {
                    console.log("üìè Desenhando linhas de triangula√ß√£o...");
                    
                    const linhas_triangulacao = new Set();  // Para evitar duplicatas
                    
                    for (const intersecao of this.interseccoes) {
                        for (const ponto_completo of intersecao.pontos_completos) {
                            const chave_linha = `${ponto_completo.nome}-${intersecao.nome}`;
                            
                            if (!linhas_triangulacao.has(chave_linha)) {
                                // Linha da triangula√ß√£o (at√© a intersec√ß√£o calculada)
                                const line = L.polyline([
                                    [ponto_completo.lat, ponto_completo.lon],
                                    [intersecao.lat, intersecao.lon]
                                ], {
                                    color: 'black',
                                    weight: 2,
                                    opacity: 0.5,
                                    dashArray: "2, 10",  // Linha bem tracejada
                                }).bindTooltip(`üìê Triangula√ß√£o: ${ponto_completo.nome} ‚Üí ${intersecao.nome}`);
                                
                                line.addTo(this.map);
                                this.currentLines.push(line);
                                linhas_triangulacao.add(chave_linha);
                            }
                        }
                    }
                }
                
                // Adiciona intersec√ß√µes com √≠cone de localiza√ß√£o vermelho
                for (const intersecao of this.interseccoes) {
                    const precisao_texto = intersecao.precisao ? `<br><b>üìä Precis√£o:</b> ${intersecao.precisao.toFixed(1)}m` : "";
                    
                    const popup_text = `
                        <div style="width:280px">
                        <b>üéØ ${intersecao.nome}</b><br>
                        <b>Tipo:</b> Intersec√ß√£o Calculada<br>
                        <b>Coordenadas:</b><br>
                        ‚Ä¢ Lat: ${intersecao.lat.toFixed(6)}<br>
                        ‚Ä¢ Lon: ${intersecao.lon.toFixed(6)}<br>
                        <b>üéØ Alvos:</b> ${intersecao.alvos.join(', ')}<br>
                        <b>üìç Pontos Origem:</b><br>
                        ‚Ä¢ ${intersecao.pontos_origem.join(' & ')}
                        ${precisao_texto}
                        </div>
                    `;
                    
                    const marker = L.marker([intersecao.lat, intersecao.lon], {
                        icon: L.divIcon({
                            html: `<i class="fas fa-map-marker" style="color:red; font-size:20px;"></i>`,
                            iconSize: [20, 20],
                            className: 'custom-icon'
                        })
                    }).bindPopup(popup_text);
                    
                    marker.addTo(this.map);
                    this.currentMarkers.push(marker);
                }
                
                // Adiciona box de informa√ß√µes
                this.addInfoBox();
                
                console.log(`‚úÖ Mapa gerado com sucesso!`);
                console.log(`üìä Pontos plotados: ${this.pontos_dados.length}`);
                console.log(`üéØ Intersec√ß√µes plotadas: ${this.interseccoes.length}`);
            }
            
            clearMap() {
                // Remove todos os marcadores e linhas do mapa
                for (const marker of this.currentMarkers) {
                    this.map.removeLayer(marker);
                }
                for (const line of this.currentLines) {
                    this.map.removeLayer(line);
                }
                this.currentMarkers = [];
                this.currentLines = [];
            }
            
            salvar_dados() {
                if (!this.pontos_dados || this.pontos_dados.length === 0) {
                    alert("‚ùå Nenhum dado para salvar!");
                    return;
                }
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const data = {
                    pontos: this.pontos_dados,
                    interseccoes: this.interseccoes
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `triangulacao_dados_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`‚úÖ Dados salvos em: triangulacao_dados_${timestamp}.json`);
            }
            
            carregar_dados(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    
                    if (!data.pontos || !Array.isArray(data.pontos)) {
                        throw new Error("Formato de arquivo inv√°lido - falta array de pontos");
                    }
                    
                    this.pontos_dados = data.pontos;
                    this.interseccoes = data.interseccoes || [];
                    
                    alert(`‚úÖ Dados carregados com sucesso!\nüìç Pontos: ${this.pontos_dados.length}\nüéØ Intersec√ß√µes: ${this.interseccoes.length}`);
                    this.updateStatus();
                    return true;
                    
                } catch (error) {
                    console.error(`‚ùå Erro ao carregar dados: ${error}`);
                    alert(`‚ùå Erro ao carregar dados: ${error.message}`);
                    return false;
                }
            }
            
            limpar_dados() {
                this.pontos_dados = [];
                this.interseccoes = [];
                this.clearMap();
                this.updateStatus();
                alert("‚úÖ Todos os dados foram limpos!");
            }
            
            updateStatus() {
                const statusBar = document.getElementById('statusBar');
                if (statusBar) {
                    statusBar.innerHTML = `üìä Status: ${this.pontos_dados.length} pontos | ${this.interseccoes.length} intersec√ß√µes`;
                }
            }
            
            // M√©todo para exemplo r√°pido (opcional)
            exemplo_rapido() {
                // Adiciona pontos de exemplo
                this.pontos_dados = [
                    {
                        nome: 'Base_Norte',
                        lat: -23.5505,
                        lon: -46.6333,
                        azimute: 135.0,
                        alvo: 'Torre_Central',
                        distancia: 1500,
                        timestamp: new Date().toLocaleString()
                    },
                    {
                        nome: 'Base_Sul',
                        lat: -23.5520,
                        lon: -46.6340,
                        azimute: 45.0,
                        alvo: 'Torre_Central',
                        distancia: 1200,
                        timestamp: new Date().toLocaleString()
                    },
                    {
                        nome: 'Base_Leste',
                        lat: -23.5515,
                        lon: -46.6320,
                        azimute: 270.0,
                        alvo: 'Antena_Oeste',
                        distancia: 800,
                        timestamp: new Date().toLocaleString()
                    }
                ];
                
                this.updateStatus();
                alert("üéØ Exemplo r√°pido carregado!\nüìç 3 pontos de exemplo adicionados\nüí° Execute a triangula√ß√£o e gere o mapa");
            }
        }
        
        // Cria inst√¢ncia do sistema
        const sistema = new SistemaTriangulacaoMelhorado();
        
        // Fun√ß√µes para intera√ß√£o com a interface
        function showAddPointModal() {
            document.getElementById('addPointModal').style.display = 'block';
            document.getElementById('pointName').focus();
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        function showViewDataModal() {
            const modal = document.getElementById('viewDataModal');
            const pointsDiv = document.getElementById('pointsData');
            const intersectionsDiv = document.getElementById('intersectionsData');
            
            // Limpa conte√∫do anterior
            pointsDiv.innerHTML = '';
            intersectionsDiv.innerHTML = '';
            
            if (sistema.pontos_dados.length === 0) {
                pointsDiv.innerHTML = '<p style="text-align:center; color:#666;">üì≠ Nenhum ponto cadastrado ainda</p>';
                intersectionsDiv.style.display = 'none';
            } else {
                // Adiciona pontos
                pointsDiv.innerHTML = `<h4 style="margin-top:0;">üìç TOTAL DE PONTOS: ${sistema.pontos_dados.length}</h4>`;
                
                for (let i = 0; i < sistema.pontos_dados.length; i++) {
                    const ponto = sistema.pontos_dados[i];
                    
                    const pontoHTML = `
                        <div class="data-item">
                            <b>üî∏ PONTO ${i+1}: ${ponto.nome}</b>
                            <p style="margin:5px 0;">
                                üìç ${ponto.lat.toFixed(6)}, ${ponto.lon.toFixed(6)}<br>
                                üß≠ Azimute: ${ponto.azimute.toFixed(1)}¬∞<br>
                                üéØ Alvo: ${ponto.alvo}<br>
                                ${ponto.distancia ? `üìè Dist√¢ncia: ${ponto.distancia}m<br>` : ''}
                                ‚è∞ Criado: ${ponto.timestamp}
                            </p>
                        </div>
                    `;
                    
                    pointsDiv.innerHTML += pontoHTML;
                }
                
                // Adiciona intersec√ß√µes se existirem
                if (sistema.interseccoes.length > 0) {
                    intersectionsDiv.style.display = 'block';
                    intersectionsDiv.innerHTML = `<h4>üéØ INTERSEC√á√ïES CALCULADAS: ${sistema.interseccoes.length}</h4>`;
                    
                    for (let i = 0; i < sistema.interseccoes.length; i++) {
                        const inter = sistema.interseccoes[i];
                        
                        const interHTML = `
                            <div class="data-item">
                                <b>üîª INTERSEC√á√ÉO ${i+1}: ${inter.nome}</b>
                                <p style="margin:5px 0;">
                                    üìç ${inter.lat.toFixed(6)}, ${inter.lon.toFixed(6)}<br>
                                    üéØ Entre alvos: ${inter.alvos.join(', ')}<br>
                                    üìê Pontos origem: ${inter.pontos_origem.join(', ')}<br>
                                    ${inter.precisao ? `üìä Precis√£o estimada: ${inter.precisao.toFixed(1)}m<br>` : ''}
                                </p>
                            </div>
                        `;
                        
                        intersectionsDiv.innerHTML += interHTML;
                    }
                } else {
                    intersectionsDiv.style.display = 'none';
                }
            }
            
            modal.style.display = 'block';
        }
        
        function addPoint() {
            const nome = document.getElementById('pointName').value.trim();
            const lat = parseFloat(document.getElementById('pointLat').value);
            const lon = parseFloat(document.getElementById('pointLon').value);
            const azimute = parseFloat(document.getElementById('pointAzimuth').value);
            const alvo = document.getElementById('pointTarget').value.trim();
            
            let distancia = null;
            if (document.getElementById('useDistance').checked) {
                distancia = parseFloat(document.getElementById('pointDistance').value);
                if (isNaN(distancia) || distancia <= 0) {
                    alert("‚ùå Dist√¢ncia deve ser maior que 0!");
                    return;
                }
            }
            
            if (sistema.adicionar_ponto_completo(nome, lat, lon, azimute, alvo, distancia)) {
                // Limpa o formul√°rio
                document.getElementById('pointName').value = '';
                document.getElementById('pointLat').value = '';
                document.getElementById('pointLon').value = '';
                document.getElementById('pointAzimuth').value = '';
                document.getElementById('pointTarget').value = '';
                document.getElementById('useDistance').checked = false;
                document.getElementById('pointDistance').style.display = 'none';
                document.getElementById('pointDistance').value = '';
                
                closeModal('addPointModal');
            }
        }
        
        function calculateTriangulation() {
            const numIntersecoes = sistema.calcular_triangulacao();
            if (numIntersecoes > 0) {
                alert(`‚úÖ Triangula√ß√£o calculada com sucesso!\nüéØ ${numIntersecoes} intersec√ß√µes encontradas`);
            }
        }
        
        function generateMap() {
            sistema.gerar_mapa();
            alert("üó∫Ô∏è Mapa gerado com sucesso!\nVisualize os pontos e intersec√ß√µes no mapa.");
        }
        
        function saveData() {
            sistema.salvar_dados();
        }
        
        function loadData() {
            document.getElementById('loadDataModal').style.display = 'block';
        }
        
        function loadDataFromFile() {
            const fileInput = document.getElementById('dataFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert("‚ùå Selecione um arquivo primeiro!");
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                sistema.carregar_dados(content);
                closeModal('loadDataModal');
            };
            reader.readAsText(file);
        }
        
        function clearData() {
            showConfirmModal(
                "Limpar todos os dados",
                `‚ö†Ô∏è Isso remover√° todos os pontos e intersec√ß√µes.<br><br>
                üìç Pontos: ${sistema.pontos_dados.length}<br>
                üéØ Intersec√ß√µes: ${sistema.interseccoes.length}<br><br>
                Confirma a limpeza?`,
                function() {
                    sistema.limpar_dados();
                    closeModal('confirmModal');
                }
            );
        }
        
        function exitSystem() {
            showConfirmModal(
                "Sair do sistema",
                "Deseja realmente sair do sistema?",
                function() {
                    if (sistema.pontos_dados.length > 0) {
                        showConfirmModal(
                            "Salvar antes de sair",
                            "Deseja salvar os dados antes de sair?",
                            function() {
                                sistema.salvar_dados();
                                closeModal('confirmModal');
                                alert("üëã Sistema encerrado com sucesso!");
                            },
                            function() {
                                closeModal('confirmModal');
                                alert("üëã Sistema encerrado com sucesso!");
                            }
                        );
                    } else {
                        alert("üëã Sistema encerrado com sucesso!");
                    }
                }
            );
        }
        
        function showConfirmModal(title, message, yesCallback, noCallback) {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').innerHTML = message;
            
            const yesBtn = document.getElementById('confirmYesBtn');
            yesBtn.onclick = function() {
                if (yesCallback) yesCallback();
                closeModal('confirmModal');
            };
            
            document.getElementById('confirmModal').style.display = 'block';
        }
        
        // Event listeners
        document.getElementById('pointAzimuth').addEventListener('input', function() {
            const azimute = parseFloat(this.value);
            if (!isNaN(azimute) && azimute >= 0 && azimute <= 360) {
                document.getElementById('azimuthDirection').textContent = 
                    `Dire√ß√£o: ${sistema.validar_azimute(azimute)}`;
            } else {
                document.getElementById('azimuthDirection').textContent = 'Dire√ß√£o: -';
            }
        });
        
        document.getElementById('useDistance').addEventListener('change', function() {
            document.getElementById('pointDistance').style.display = this.checked ? 'block' : 'none';
        });
        
        // Pergunta se quer carregar exemplo r√°pido
        document.addEventListener('DOMContentLoaded', function() {
            const usarExemplo = confirm("üöÄ Deseja carregar um exemplo r√°pido para demonstra√ß√£o?");
            if (usarExemplo) {
                sistema.exemplo_rapido();
            }
        });
    </script>
</body>
</html>
